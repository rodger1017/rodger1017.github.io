---
title: iOS GCD(Grand Central Dispatch) 总结
layout: posts
categories: iOS
tag: objc
---

# GCD简介
## 定义
Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。

- [wiki](https://en.wikipedia.org/wiki/Grand_Central_Dispatch)
- [百度百科](https://baike.baidu.com/item/GCD/2104053)

## 任务(同步/异步)
- 代码模板

```objc
dispatch_sync(..., ^(block))
dispatch_async(..., ^(block))
```

- 同步执行（sync）：
1. 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。
2. 只能在当前线程中执行任务，不具备开启新线程的能力。

- 异步执行(async)：
1. 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。
2. 可以在新的线程中执行任务，具备开启新线程的能力。

> 注意：异步执行(async)虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关。

## [Dispatch Queue](https://developer.apple.com/documentation/dispatch/dispatch_queue?language=objc) 队列(FIFO)

- 串行队列(Serial Dispatch Queue): 每次只有一个任务被执行。常用于同步访问特定的资源或数据。当创建多个 Serial queue 时，虽然各自是同步，但 serial queue 之间是并发执行。
- 并行队列(Concurrent Dispatch Queue): 可以多任务并发（同时）执行。

> 操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在主线程执行了

### 系统标准队列

```objc
// 全局串行队列，在应用程序主线程执行
dispatch_get_main_queue()

// 全局并发队列，总共4个，对应4中不同优先级
#define DISPATCH_QUEUE_PRIORITY_HIGH 2
#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0
#define DISPATCH_QUEUE_PRIORITY_LOW (-2)
#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN
dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)
```

### 自定义队列

```objc
// 串行队列
dispatch_queue_create("com.rodgerjluo.serialqueue", DISPATCH_QUEUE_SERIAL)
// 并行队列
dispatch_queue_create("com.rodgerjluo.concurrentqueue", DISPATCH_QUEUE_CONCURRENT)
```

[dispatch_queue_create](https://developer.apple.com/documentation/dispatch/1453030-dispatch_queue_create) 声明：

```objc
dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
```

- `label`: 队列名，可选参数，可为`NULL`;
- `attr`: 队列类型，默认为`DISPATCH_QUEUE_SERIAL`或`NULL`;

自定义队列优先级设置：
- [dispatch_queue_attr_make_with_qos_class](https://developer.apple.com/documentation/dispatch/1453028-dispatch_queue_attr_make_with_qo)：设置队列的优先级；

```objc
dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);
dispatch_queue_t queue = dispatch_queue_create("com.rodgerjluo.gcddemo.qosqueue", attr);
dispatch_queue_t queue = dispatch_queue_create("com.rodgerjluo.gcddemo.settargetqueue", NULL); 
dispatch_queue_t referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); 
dispatch_set_target_queue(queue, referQueue); 
```

- [dispatch_set_target_queue](https://developer.apple.com/documentation/dispatch/1452989-dispatch_set_target_queue?language=occ)：可以设置优先级，也可以设置队列层级体系；

```objc
- (void)dispatchSetTargetQueueDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchSetTargetQueueDemo---begin");
    dispatch_queue_t serialQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t firstQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.firstqueue", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t secondQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.secondqueue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_set_target_queue(firstQueue, serialQueue);
    dispatch_set_target_queue(secondQueue, serialQueue);
    
    dispatch_async(firstQueue, ^{
        NSLog(@"1---%@", [NSThread currentThread]);
        [NSThread sleepForTimeInterval:3.f];
    });
    dispatch_async(secondQueue, ^{
        NSLog(@"2---%@", [NSThread currentThread]);
        [NSThread sleepForTimeInterval:2.f];
    });
    dispatch_async(secondQueue, ^{
        NSLog(@"3---%@", [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.f];
    });
    NSLog(@"dispatchSetTargetQueueDemo---end");
}
```

执行结果：

```
2020-01-01 14:57:23.764441+0800 GCDDemo[24755:2840724] currentThread---<NSThread: 0x600001c4cb80>{number = 1, name = main}
2020-01-01 14:57:23.764557+0800 GCDDemo[24755:2840724] dispatchSetTargetQueueDemo---begin
2020-01-01 14:57:23.764664+0800 GCDDemo[24755:2840724] dispatchSetTargetQueueDemo---end
2020-01-01 14:57:23.764712+0800 GCDDemo[24755:2840849] 1---<NSThread: 0x600001c0dc40>{number = 5, name = (null)}
2020-01-01 14:57:26.765488+0800 GCDDemo[24755:2840849] 2---<NSThread: 0x600001c0dc40>{number = 5, name = (null)}
2020-01-01 14:57:28.767272+0800 GCDDemo[24755:2840849] 3---<NSThread: 0x600001c0dc40>{number = 5, name = (null)}
```

### 队列优先级与QOS对应关系
iOS8 之后引入 QOS 概念，与之前队列优先级对应关系如下：

| 优先级 | QOS | 说明 |
| - | - | - |
| Main Thread | QOS_CLASS_USER_INTERACTIVE | UI相关，交互等 |
| DISPATCH_QUEUE_PRIORITY_HIGH | QOS_CLASS_USER_INITIATED | 用户发起需要马上得到结果进行后续任务 |
| DISPATCH_QUEUE_PRIORITY_DEFAULT | QOS_CLASS_DEFAULT | 默认，不应该使用这个设置任务 |
| DISPATCH_QUEUE_PRIORITY_LOW | QOS_CLASS_UTILITY | 花费时间稍多比如下载，需要几秒或几分钟的 |
| DISPATCH_QUEUE_PRIORITY_BACKGROUND | QOS_CLASS_BACKGROUND | 不可见在后台的操作可能需要好几分钟甚至几小时的 |

- `QOS_CLASS_USER_INTERACTIVE`：表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。
- `QOS_CLASS_USER_INITIATED`：表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。
- `QOS_CLASS_UTILITY`：表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。
- `QOS_CLASS_BACKGROUND`：表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。


## 不同任务与队列组合分析

| 类型 | 并发队列 | 串行队列 | 主队列 |
| - | - | - | - |
| 同步(sync) | 没有开启新线程，串行执行任务 | 没有开启新线程，串行执行任务 | 死锁卡住不执行 |
| 异步(async) | 有开启新线程，并发执行任务 | 有开启新线程（1条），串行执行任务 | 没有开启新线程，串行执行任务 |

- 主线程中调用同步+主队列方式会导致死锁，原因是追加的同步任务与正在执行的任务出现互等阻塞；
- 非主线调用同步+主队列方式不会导致死锁，任务添加到主队列后串行执行；

### 同步 + 并发队列
在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。

```objc
/**
 * 同步执行 + 并发队列
 * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。
 */
- (void)dispatchSyncConcurrentDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchSyncConcurrentDemo---begin");
    
    dispatch_queue_t queue = dispatch_queue_create("com.rodgerjluo.gcddemo.concurrentqueue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchSyncConcurrentDemo---end");
}
```

执行结果：

```
2020-01-01 14:59:02.880426+0800 GCDDemo[24908:2850037] currentThread---<NSThread: 0x6000024ccd80>{number = 1, name = main}
2020-01-01 14:59:02.880546+0800 GCDDemo[24908:2850037] dispatchSyncConcurrentDemo---begin
2020-01-01 14:59:04.881811+0800 GCDDemo[24908:2850037] 1---<NSThread: 0x6000024ccd80>{number = 1, name = main}
2020-01-01 14:59:06.883115+0800 GCDDemo[24908:2850037] 2---<NSThread: 0x6000024ccd80>{number = 1, name = main}
2020-01-01 14:59:08.884376+0800 GCDDemo[24908:2850037] 3---<NSThread: 0x6000024ccd80>{number = 1, name = main}
2020-01-01 14:59:08.884541+0800 GCDDemo[24908:2850037] dispatchSyncConcurrentDemo---end
```

### 异步 + 并发队列
可以开启多个线程，任务交替（同时）执行。

```objc
/**
 * 异步执行 + 并发队列
 * 特点：可以开启多个线程，任务交替（同时）执行。
 */
- (void)dispatchAsyncConcurrentDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchAsyncConcurrentDemo---begin");
    
    dispatch_queue_t queue = dispatch_queue_create("com.rodgerjluo.gcddemo.concurrentqueue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchAsyncConcurrentDemo---end");
}
```

执行结果：

```
2020-01-01 15:05:47.662591+0800 GCDDemo[25485:2883851] currentThread---<NSThread: 0x600001374040>{number = 1, name = main}
2020-01-01 15:05:47.662714+0800 GCDDemo[25485:2883851] dispatchAsyncConcurrentDemo---begin
2020-01-01 15:05:47.662827+0800 GCDDemo[25485:2883851] dispatchAsyncConcurrentDemo---end
2020-01-01 15:05:49.668134+0800 GCDDemo[25485:2884063] 1---<NSThread: 0x60000133d240>{number = 4, name = (null)}
2020-01-01 15:05:49.668133+0800 GCDDemo[25485:2884062] 2---<NSThread: 0x60000130a300>{number = 6, name = (null)}
2020-01-01 15:05:49.668171+0800 GCDDemo[25485:2884061] 3---<NSThread: 0x6000013e0180>{number = 7, name = (null)}
```

### 同步 + 串行队列
不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。

```objc
/**
 * 同步执行 + 串行队列
 * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。
 */
- (void)dispatchSyncSerialDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchSyncSerialDemo---begin");
    
    dispatch_queue_t queue = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    
    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchSyncSerialDemo---end");
}
```

执行结果：

```
2020-01-01 15:10:51.731495+0800 GCDDemo[25963:2907468] currentThread---<NSThread: 0x6000008d5d40>{number = 1, name = main}
2020-01-01 15:10:51.731621+0800 GCDDemo[25963:2907468] dispatchSyncSerialDemo---begin
2020-01-01 15:10:53.732779+0800 GCDDemo[25963:2907468] 1---<NSThread: 0x6000008d5d40>{number = 1, name = main}
2020-01-01 15:10:55.734049+0800 GCDDemo[25963:2907468] 2---<NSThread: 0x6000008d5d40>{number = 1, name = main}
2020-01-01 15:10:57.735358+0800 GCDDemo[25963:2907468] 3---<NSThread: 0x6000008d5d40>{number = 1, name = main}
2020-01-01 15:10:57.735478+0800 GCDDemo[25963:2907468] dispatchSyncSerialDemo---end
```

### 异步 + 串行队列
会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务

```objc
/**
 * 异步执行 + 串行队列
 * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。
 */
- (void)dispatchAsyncSerialDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchAsyncSerialDemo---begin");
    
    dispatch_queue_t queue = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchAsyncSerialDemo---end");
}
```

执行结果：

```
2020-01-01 15:12:16.540125+0800 GCDDemo[26092:2914778] currentThread---<NSThread: 0x600002c81480>{number = 1, name = main}
2020-01-01 15:12:16.540241+0800 GCDDemo[26092:2914778] dispatchAsyncSerialDemo---begin
2020-01-01 15:12:16.540343+0800 GCDDemo[26092:2914778] dispatchAsyncSerialDemo---end
2020-01-01 15:12:18.544172+0800 GCDDemo[26092:2915056] 1---<NSThread: 0x600002cd6300>{number = 6, name = (null)}
2020-01-01 15:12:20.548111+0800 GCDDemo[26092:2915056] 2---<NSThread: 0x600002cd6300>{number = 6, name = (null)}
2020-01-01 15:12:22.548404+0800 GCDDemo[26092:2915056] 3---<NSThread: 0x600002cd6300>{number = 6, name = (null)}
```

### 同步 + 主队列 + 主线程
互相等待卡住不可行

```objc
/**
 * 同步执行 + 主队列
 * 特点(主线程调用)：互等卡主不执行。
 * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。
 */
- (void)dispatchSyncMainDemo {
    
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchSyncMainDemo---begin");
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchSyncMainDemo---end");
}
```

执行结果：

```
2020-01-01 15:14:02.776986+0800 GCDDemo[26240:2924024] currentThread---<NSThread: 0x6000018f5900>{number = 1, name = main}
2020-01-01 15:14:02.777110+0800 GCDDemo[26240:2924024] dispatchSyncMainDemo---begin

Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)
```

### 同步 + 主队列 + 非主线程
不会开启新线程，执行完一个任务，再执行下一个任务

```objc
// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行 selector 任务
[NSThread detachNewThreadSelector:@selector(dispatchSyncMainDemo) toTarget:self withObject:nil];
```

执行结果：

```
2020-01-01 15:16:53.776190+0800 GCDDemo[26464:2939083] currentThread---<NSThread: 0x600001160a40>{number = 6, name = (null)}
2020-01-01 15:16:53.776314+0800 GCDDemo[26464:2939083] dispatchSyncMainDemo---begin
2020-01-01 15:16:55.789089+0800 GCDDemo[26464:2938909] 1---<NSThread: 0x6000011086c0>{number = 1, name = main}
2020-01-01 15:16:57.800397+0800 GCDDemo[26464:2938909] 2---<NSThread: 0x6000011086c0>{number = 1, name = main}
2020-01-01 15:16:59.800774+0800 GCDDemo[26464:2938909] 3---<NSThread: 0x6000011086c0>{number = 1, name = main}
2020-01-01 15:16:59.800963+0800 GCDDemo[26464:2939083] dispatchSyncMainDemo---end
```

### 异步 + 主队列
只在主线程中执行任务，执行完一个任务，再执行下一个任务。

```objc
/**
 * 异步执行 + 主队列
 * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务
 */
- (void)dispatchAsyncMainDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchAsyncMainDemo---begin");
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchAsyncMainDemo---end");
}
```

执行结果：

```
2020-01-01 15:18:18.842422+0800 GCDDemo[26591:2946428] currentThread---<NSThread: 0x6000039511c0>{number = 1, name = main}
2020-01-01 15:18:18.842536+0800 GCDDemo[26591:2946428] dispatchAsyncMainDemo---begin
2020-01-01 15:18:18.842636+0800 GCDDemo[26591:2946428] dispatchAsyncMainDemo---end
2020-01-01 15:18:20.854481+0800 GCDDemo[26591:2946428] 1---<NSThread: 0x6000039511c0>{number = 1, name = main}
2020-01-01 15:18:22.855129+0800 GCDDemo[26591:2946428] 2---<NSThread: 0x6000039511c0>{number = 1, name = main}
2020-01-01 15:18:24.856467+0800 GCDDemo[26591:2946428] 3---<NSThread: 0x6000039511c0>{number = 1, name = main}
```

## 队列嵌套组合分析
同一队列嵌套场景分析：

| 类型 | 异步+并发 | 同步+并发 | 异步+串行 | 同步+串行 |
| - | - | - | - | - |
| 同步(sync) | 没有开启新线程，串行执行任务 | 没有开启新线程，串行执行任务 | 死锁卡住不执行 | 死锁卡住不执行 |
| 异步(async) | 有开启新线程，并发执行任务 | 有开启新线程，并发执行任务 | 有开启新线程（1 条），串行执行任务 | 有开启新线程（1 条），串行执行任务 |

## GCD线程间通信
在 iOS 中，我们一般会将耗时操作放在子线程中执行，执行完成中将结果抛回主线程进行 UI 相关操作。

```objc
/**
 * 线程间通信
 */
- (void)dispatchCommunicationDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchCommunicationDemo---begin");
    // 获取全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    // 获取主队列
    dispatch_queue_t mainQueue = dispatch_get_main_queue();
    
    dispatch_async(queue, ^{
        // 异步追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);      // 打印当前线程
        
        // 回到主线程
        dispatch_async(mainQueue, ^{
            // 追加在主线程中执行的任务
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@"2---%@", [NSThread currentThread]);      // 打印当前线程
        });
    });
    
    NSLog(@"dispatchCommunicationDemo---end");
}
```

执行结果：

```
2020-01-01 15:21:01.509456+0800 GCDDemo[26874:2961464] currentThread---<NSThread: 0x6000016249c0>{number = 1, name = main}
2020-01-01 15:21:01.509578+0800 GCDDemo[26874:2961464] dispatchCommunicationDemo---begin
2020-01-01 15:21:01.509675+0800 GCDDemo[26874:2961464] dispatchCommunicationDemo---end
2020-01-01 15:21:03.510020+0800 GCDDemo[26874:2961738] 1---<NSThread: 0x600001667000>{number = 5, name = (null)}
2020-01-01 15:21:05.511312+0800 GCDDemo[26874:2961464] 2---<NSThread: 0x6000016249c0>{number = 1, name = main}
```

# GCD其它用法
## [dispatch_once](https://developer.apple.com/documentation/dispatch/1447169-dispatch_once?language=objc)
- `dispatch_once` 保证代码在程序运行期间只执行一次。
- `dispatch_once_t` 要是全局或 static 变量，保证 `dispatch_once_t` 只有一份实例。

```objc
/**
 * 一次性代码（只执行一次）dispatch_once
 */
- (void)dispatchOnceDemo {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        // 只执行 1 次的代码（这里面默认是线程安全的）
    });
}
```

## [dispatch_after](https://developer.apple.com/documentation/dispatch/1452876-dispatch_after?language=objc)
`dispatch_after` 只是延时提交 block，不是延时执行。这个时间不一定准确，适用于大致延迟一段时间执行的场景。

```objc
/**
 * 延时执行方法 dispatch_after
 */
- (void)dispatchAfterDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchAfterDemo---begin");
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        // 2.0 秒后异步追加任务代码到主队列，并开始执行
        NSLog(@"after---%@", [NSThread currentThread]);  // 打印当前线程
    });
    
    NSLog(@"dispatchAfterDemo---end");
}
```

执行结果：

```
2020-01-01 15:27:40.850464+0800 GCDDemo[27378:2985766] currentThread---<NSThread: 0x6000014b00c0>{number = 1, name = main}
2020-01-01 15:27:40.850591+0800 GCDDemo[27378:2985766] dispatchAfterDemo---begin
2020-01-01 15:27:40.850688+0800 GCDDemo[27378:2985766] dispatchAfterDemo---end
2020-01-01 15:27:42.850971+0800 GCDDemo[27378:2985766] after---<NSThread: 0x6000014b00c0>{number = 1, name = main}
```

`dispatch_time` 函数第一个参数`DISPATCH_TIME_NOW` 表示当前时间，第二个参数 delta 表示纳秒，一秒等于1000000000纳秒，系统提供了一些简化宏：

```objc
#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒
#define USEC_PER_SEC 1000000ull    //每秒有多少毫秒
#define NSEC_PER_USEC 1000ull      //每毫秒有多少纳秒

// 1秒钟不同表示方法
dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);
dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);
dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC);
```

## [dispatch_apply](https://developer.apple.com/documentation/dispatch/1453050-dispatch_apply?language=occ)
`dispatch_apply` 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。
在串行队列中使用 `dispatch_apply`，功能于 `for` 循环相同，按顺序同步执行。
在并行队列中异步执行可以在多线程中同时执行多项任务。

注意，无论是串行队列还是并行队列，`dispatch_apply` 都会等待全部任务执行完成，类似队列组中的 `dispatch_group_wait` 方法。

```objc
/**
 * 快速迭代方法 dispatch_apply
 */
- (void)dispatchApplyDemo {
    NSLog(@"dispatchApplyDemo---begin");
    dispatch_queue_t concurrentQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.concurrentqueue", DISPATCH_QUEUE_CONCURRENT);
    dispatch_apply(5, concurrentQueue, ^(size_t i) {
        NSLog(@"%zu---%@", i, [NSThread currentThread]);
    });
    NSLog(@"dispatchApplyDemo---end");
}
```

执行结果：

```
2020-01-01 15:43:59.728971+0800 GCDDemo[28832:3066581] dispatchApplyDemo---begin
2020-01-01 15:43:59.729145+0800 GCDDemo[28832:3066581] 0---<NSThread: 0x60000227cd00>{number = 1, name = main}
2020-01-01 15:43:59.729149+0800 GCDDemo[28832:3066808] 1---<NSThread: 0x600002215600>{number = 6, name = (null)}
2020-01-01 15:43:59.729149+0800 GCDDemo[28832:3066801] 2---<NSThread: 0x60000221c280>{number = 5, name = (null)}
2020-01-01 15:43:59.729173+0800 GCDDemo[28832:3066802] 3---<NSThread: 0x600002253180>{number = 4, name = (null)}
2020-01-01 15:43:59.729189+0800 GCDDemo[28832:3066805] 4---<NSThread: 0x600002214000>{number = 3, name = (null)}
2020-01-01 15:43:59.729280+0800 GCDDemo[28832:3066581] dispatchApplyDemo---end
```

> 注意：`dispatch_apply` 会阻塞主线程。这个 log 打印会在 `dispatch_apply` 都结束后才开始执行，但是使用 `dispatch_async` 包一下就不会阻塞了。

```objc
/**
 * 快速迭代方法 dispatch_apply
 */
- (void)dispatchApplyDemo {
    NSLog(@"dispatchApplyDemo---begin");
    dispatch_queue_t concurrentQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.concurrentqueue", DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(dispatch_get_main_queue(), ^{
        dispatch_apply(5, concurrentQueue, ^(size_t i) {
            NSLog(@"%zu---%@", i, [NSThread currentThread]);
        });
    });
    NSLog(@"dispatchApplyDemo---end");
}
```

执行结果：

```
2020-01-01 15:44:22.734829+0800 GCDDemo[28878:3069107] dispatchApplyDemo---begin
2020-01-01 15:44:22.734941+0800 GCDDemo[28878:3069107] dispatchApplyDemo---end
2020-01-01 15:44:22.745110+0800 GCDDemo[28878:3069107] 0---<NSThread: 0x600001866d00>{number = 1, name = main}
2020-01-01 15:44:22.745116+0800 GCDDemo[28878:3069313] 1---<NSThread: 0x60000187d900>{number = 6, name = (null)}
2020-01-01 15:44:22.745160+0800 GCDDemo[28878:3069318] 2---<NSThread: 0x600001802340>{number = 3, name = (null)}
2020-01-01 15:44:22.745228+0800 GCDDemo[28878:3069313] 3---<NSThread: 0x60000187d900>{number = 6, name = (null)}
2020-01-01 15:44:22.745242+0800 GCDDemo[28878:3069107] 4---<NSThread: 0x600001866d00>{number = 1, name = main}
```

`dispatch_apply` 能避免线程爆炸，因为GCD会管理并发。

```objc
/**
 * 避免线程爆炸
 */
- (void)dispatchApplyThreadExplodeDemo:(BOOL)explode {
    NSLog(@"dispatchApplyThreadExplodeDemo---begin");
    dispatch_queue_t concurrentQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.concurrentqueue",DISPATCH_QUEUE_CONCURRENT);
    if (explode) {
        // 有问题的情况，可能会死锁
        for (int i = 0; i < 999 ; i++) {
            dispatch_async(concurrentQueue, ^{
                NSLog(@"wrong %d---%@", i, [NSThread currentThread]);
                //do something hard
            });
        }
    } else {
        //会优化很多，能够利用GCD管理
        dispatch_apply(999, concurrentQueue, ^(size_t i){
            NSLog(@"correct %zu---%@", i, [NSThread currentThread]);
            //do something hard
        });
    }
    
    NSLog(@"dispatchApplyThreadExplodeDemo---end");
}
```

## [Dispatch Barrier](https://developer.apple.com/documentation/dispatch/dispatch_barrier?language=objc)
`barrier` 是栅栏的意思，也就是将两组异步执行的操作组合分开，`dispatch_barrier_async` 会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中，等待该任务执行完成后，异步队列才恢复正常执行。

注意 `dispatch_barrier_async` 只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样

```objc
/**
 * 栅栏方法 dispatch_barrier_async
 */
- (void)dispatchBarrierAsyncDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchBarrierAsyncDemo---begin");
    dispatch_queue_t queue = dispatch_queue_create("com.rodgerjluo.gcddemo.concurrentqueue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_barrier_async(queue, ^{
        // 追加任务 barrier
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"barrier---%@", [NSThread currentThread]);   // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2.f];                  // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);           // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 4
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"4---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchBarrierAsyncDemo---end");
}
```

执行结果：

```
2020-01-01 15:52:30.212273+0800 GCDDemo[29595:3111484] currentThread---<NSThread: 0x600002464a80>{number = 1, name = main}
2020-01-01 15:52:30.212386+0800 GCDDemo[29595:3111484] dispatchBarrierAsyncDemo---begin
2020-01-01 15:52:30.212487+0800 GCDDemo[29595:3111484] dispatchBarrierAsyncDemo---end
2020-01-01 15:52:32.212893+0800 GCDDemo[29595:3111756] 2---<NSThread: 0x60000241d080>{number = 5, name = (null)}
2020-01-01 15:52:32.212931+0800 GCDDemo[29595:3111761] 1---<NSThread: 0x6000024058c0>{number = 6, name = (null)}
2020-01-01 15:52:34.215890+0800 GCDDemo[29595:3111761] barrier---<NSThread: 0x6000024058c0>{number = 6, name = (null)}
2020-01-01 15:52:36.218445+0800 GCDDemo[29595:3111756] 4---<NSThread: 0x60000241d080>{number = 5, name = (null)}
2020-01-01 15:52:36.218446+0800 GCDDemo[29595:3111761] 3---<NSThread: 0x6000024058c0>{number = 6, name = (null)}
```

## [Dispatch Group](https://developer.apple.com/documentation/dispatch/dispatch_group?language=objc)
`disptach group` 用来处理多个异步任务，例如任务A和B需要在任务C之前执行，A和B可以同步执行，这时可以将A和B放在用 `dispatch_group_t` 标识的任务组中，等待A和B都执行完成后再执行C。

任务组中的任务执行完成后有两种方式发送通知：
1. `dispatch_group_wait`: 回到当前线程继续执行，会阻塞当前线程；
2. `dispatch_group_notify`: 回到指定线程执行，不会阻塞当前线程。

注意事项：
- `dispatch_group_async` 等价于 `dispatch_group_enter` 和 `dispatch_group_leave` 的组合。
- `dispatch_group_enter` 必须运行在 `dispatch_group_leave` 之前。
- `dispatch_group_enter` 和 `dispatch_group_leave` 需要成对出现的

### [dispatch_group_notify](https://developer.apple.com/documentation/dispatch/1452933-dispatch_group_notify?language=occ)
监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。

```objc
/**
 * 队列组 dispatch_group_notify
 */
- (void)dispatchGroupNotifyDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchGroupNotifyDemo---begin");
    
    dispatch_group_t group =  dispatch_group_create();
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 等前面的异步任务 1、任务 2 都执行完毕后，回到主线程执行下边任务
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchGroupNotifyDemo---end");
}
```

执行结果：

```
2020-01-01 16:02:35.473941+0800 GCDDemo[30447:3161899] currentThread---<NSThread: 0x600002046180>{number = 1, name = main}
2020-01-01 16:02:35.474075+0800 GCDDemo[30447:3161899] dispatchGroupNotifyDemo---begin
2020-01-01 16:02:35.474182+0800 GCDDemo[30447:3161899] dispatchGroupNotifyDemo---end
2020-01-01 16:02:37.479175+0800 GCDDemo[30447:3162175] 2---<NSThread: 0x60000206dbc0>{number = 5, name = (null)}
2020-01-01 16:02:37.479175+0800 GCDDemo[30447:3162174] 1---<NSThread: 0x6000020185c0>{number = 4, name = (null)}
2020-01-01 16:02:39.479689+0800 GCDDemo[30447:3161899] 3---<NSThread: 0x600002046180>{number = 1, name = main}
```

### [dispatch_group_wait](https://developer.apple.com/documentation/dispatch/1452794-dispatch_group_wait?language=occ)
暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。

```objc
/**
 * 队列组 dispatch_group_wait
 */
- (void)dispatchGroupWaitDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchGroupWaitDemo---begin");
    
    dispatch_group_t group =  dispatch_group_create();
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    
    NSLog(@"dispatchGroupWaitDemo---end");
}
```

执行结果：

```
2020-01-01 16:03:16.188030+0800 GCDDemo[30499:3165948] currentThread---<NSThread: 0x6000003242c0>{number = 1, name = main}
2020-01-01 16:03:16.188148+0800 GCDDemo[30499:3165948] dispatchGroupWaitDemo---begin
2020-01-01 16:03:18.190046+0800 GCDDemo[30499:3166153] 1---<NSThread: 0x600000370b00>{number = 4, name = (null)}
2020-01-01 16:03:18.190051+0800 GCDDemo[30499:3166152] 2---<NSThread: 0x600000340300>{number = 5, name = (null)}
2020-01-01 16:03:18.190187+0800 GCDDemo[30499:3165948] dispatchGroupWaitDemo---end
```

### [dispatch_group_enter](https://developer.apple.com/documentation/dispatch/1452803-dispatch_group_enter?language=occ) [dispatch_group_leave](https://developer.apple.com/documentation/dispatch/1452872-dispatch_group_leave?language=objc)
- `dispatch_group_enter` 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数 +1
- `dispatch_group_leave` 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数 -1。
- 当 group 中未执行完毕任务数为0的时候，才会使 `dispatch_group_wait` 解除阻塞，以及执行追加到 `dispatch_group_notify` 中的任务。

```objc
/**
 * 队列组 dispatch_group_enter、dispatch_group_leave
 */
- (void)dispatchGroupEnterAndLeaveDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchGroupEnterAndLeaveDemo---begin");
    
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_enter(group);
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程

        dispatch_group_leave(group);
    });
    
    dispatch_group_enter(group);
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]);         // 打印当前线程
        
        dispatch_group_leave(group);
    });
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 等前面的异步操作都执行完毕后，回到主线程.
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"3---%@", [NSThread currentThread]);         // 打印当前线程
    });
    
    NSLog(@"dispatchGroupEnterAndLeaveDemo---end");
}
```

执行结果：

```
2020-01-01 16:04:15.100839+0800 GCDDemo[30589:3171713] currentThread---<NSThread: 0x6000022880c0>{number = 1, name = main}
2020-01-01 16:04:15.101360+0800 GCDDemo[30589:3171713] dispatchGroupEnterAndLeaveDemo---begin
2020-01-01 16:04:15.101686+0800 GCDDemo[30589:3171713] dispatchGroupEnterAndLeaveDemo---end
2020-01-01 16:04:17.103908+0800 GCDDemo[30589:3171935] 1---<NSThread: 0x6000022c2600>{number = 3, name = (null)}
2020-01-01 16:04:17.103925+0800 GCDDemo[30589:3171928] 2---<NSThread: 0x600002282ec0>{number = 4, name = (null)}
2020-01-01 16:04:19.105282+0800 GCDDemo[30589:3171713] 3---<NSThread: 0x6000022880c0>{number = 1, name = main}
```

## [Dispatch Work Item](https://developer.apple.com/documentation/dispatch/dispatch_work_item?language=objc)
队列执行任务都是block的方式。

### [dispatch_block_create](https://developer.apple.com/documentation/dispatch/1431050-dispatch_block_create?language=objc)

```objc
/**
 * 创建 dispatch_block_create
 */
- (void)dispatchCreateBlockDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchCreateBlockDemo---begin");
    
    // normal way
    dispatch_queue_t concurrentQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.concurrentqueue", DISPATCH_QUEUE_CONCURRENT);
    dispatch_block_t block = dispatch_block_create(0, ^{
        NSLog(@"1---%@", [NSThread currentThread]);
    });
    dispatch_async(concurrentQueue, block);
    
    // QOS way
    dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^{
        NSLog(@"2---%@", [NSThread currentThread]);
    });
    dispatch_async(concurrentQueue, qosBlock);
    
    NSLog(@"dispatchCreateBlockDemo---end");
}
```

执行结果：

```
2020-01-01 16:14:58.466145+0800 GCDDemo[31491:3219196] currentThread---<NSThread: 0x600000d68500>{number = 1, name = main}
2020-01-01 16:14:58.466273+0800 GCDDemo[31491:3219196] dispatchCreateBlockDemo---begin
2020-01-01 16:14:58.466372+0800 GCDDemo[31491:3219196] dispatchCreateBlockDemo---end
2020-01-01 16:14:58.466402+0800 GCDDemo[31491:3219468] 1---<NSThread: 0x600000d67b80>{number = 4, name = (null)}
2020-01-01 16:14:58.466445+0800 GCDDemo[31491:3219472] 2---<NSThread: 0x600000d01b40>{number = 7, name = (null)}
```

### [dispatch_block_wait](https://developer.apple.com/documentation/dispatch/1431064-dispatch_block_wait?language=objc)
设置 block 等待时间，`DISPATCH_TIME_FOREVER` 表示一直等待。

```objc
/**
 * 等待 dispatch_block_wait
 */
- (void)dispatchBlockWaitDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchBlockWaitDemo---begin");
    
    dispatch_queue_t serialQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block = dispatch_block_create(0, ^{
        NSLog(@"1---%@", [NSThread currentThread]);
        [NSThread sleepForTimeInterval:5.f];
        NSLog(@"2---%@",  [NSThread currentThread]);
    });
    dispatch_async(serialQueue, block);
    // 设置 DISPATCH_TIME_FOREVER 会一直等到前面任务都完成
    dispatch_block_wait(block, DISPATCH_TIME_FOREVER);
    
    NSLog(@"dispatchBlockWaitDemo---end");
}
```

执行结果：

```
2020-01-01 16:16:13.205468+0800 GCDDemo[31598:3225833] currentThread---<NSThread: 0x600000328e00>{number = 1, name = main}
2020-01-01 16:16:13.205606+0800 GCDDemo[31598:3225833] dispatchBlockWaitDemo---begin
2020-01-01 16:16:13.205738+0800 GCDDemo[31598:3226069] 1---<NSThread: 0x60000036ce80>{number = 5, name = (null)}
2020-01-01 16:16:18.206058+0800 GCDDemo[31598:3226069] 2---<NSThread: 0x60000036ce80>{number = 5, name = (null)}
2020-01-01 16:16:18.206195+0800 GCDDemo[31598:3225833] dispatchBlockWaitDemo---end
```

### [dispatch_block_notify](https://developer.apple.com/documentation/dispatch/1431042-dispatch_block_notify?language=objc)
监视指定 dispatch block 结束，然后再加入一个 block 到队列中。三个参数分别为，第一个是需要监视的 block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的 block。

```objc
/**
 * 通知 dispatch_block_notify
 */
- (void)dispatchBlockNotifyDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchBlockNotifyDemo---begin");
    
    dispatch_queue_t serialQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t firstBlock = dispatch_block_create(0, ^{
        NSLog(@"1---%@", [NSThread currentThread]);
        [NSThread sleepForTimeInterval:2.f];
        NSLog(@"2---%@", [NSThread currentThread]);
    });
    dispatch_async(serialQueue, firstBlock);
    dispatch_block_t secondBlock = dispatch_block_create(0, ^{
        NSLog(@"3---%@", [NSThread currentThread]);
    });
    // first block执行完才在serial queue中执行second block
    dispatch_block_notify(firstBlock, serialQueue, secondBlock);
    
    NSLog(@"dispatchBlockNotifyDemo---end");
}
```

执行结果：

```
2020-01-01 16:16:43.957905+0800 GCDDemo[31642:3229240] currentThread---<NSThread: 0x600000e678c0>{number = 1, name = main}
2020-01-01 16:16:43.958014+0800 GCDDemo[31642:3229240] dispatchBlockNotifyDemo---begin
2020-01-01 16:16:43.958111+0800 GCDDemo[31642:3229240] dispatchBlockNotifyDemo---end
2020-01-01 16:16:43.958143+0800 GCDDemo[31642:3229437] 1---<NSThread: 0x600000e00580>{number = 4, name = (null)}
2020-01-01 16:16:45.963044+0800 GCDDemo[31642:3229437] 2---<NSThread: 0x600000e00580>{number = 4, name = (null)}
2020-01-01 16:16:45.963179+0800 GCDDemo[31642:3229437] 3---<NSThread: 0x600000e00580>{number = 4, name = (null)}
```

### [dispatch_block_cancel](https://developer.apple.com/documentation/dispatch/1431058-dispatch_block_cancel?language=occ)

```objc
/**
 * 取消 dispatch_block_cancel(iOS8+)
 */
- (void)dispatchBlockCancelDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchBlockCancelDemo---begin");
    
    dispatch_queue_t serialQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t firstBlock = dispatch_block_create(0, ^{
        NSLog(@"1---%@", [NSThread currentThread]);
        [NSThread sleepForTimeInterval:2.f];
        NSLog(@"2---%@", [NSThread currentThread]);
    });
    dispatch_block_t secondBlock = dispatch_block_create(0, ^{
        NSLog(@"3---%@", [NSThread currentThread]);
    });
    dispatch_async(serialQueue, firstBlock);
    dispatch_async(serialQueue, secondBlock);
    // 取消secondBlock
    dispatch_block_cancel(secondBlock);
    
    NSLog(@"dispatchBlockCancelDemo---end");
}
```

执行结果：

```
2020-01-01 16:17:51.584556+0800 GCDDemo[31730:3236141] currentThread---<NSThread: 0x600003c6ecc0>{number = 1, name = main}
2020-01-01 16:17:51.584668+0800 GCDDemo[31730:3236141] dispatchBlockCancelDemo---begin
2020-01-01 16:17:51.584767+0800 GCDDemo[31730:3236141] dispatchBlockCancelDemo---end
2020-01-01 16:17:51.584788+0800 GCDDemo[31730:3236362] 1---<NSThread: 0x600003c0c540>{number = 4, name = (null)}
2020-01-01 16:17:53.586578+0800 GCDDemo[31730:3236362] 2---<NSThread: 0x600003c0c540>{number = 4, name = (null)}
```

## Dispatch IO 文件操作
dispatch io 读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文
件这样会比单线程要快很多。

```objc
dispatch_async(queue,^{/*read 0-99 bytes*/});
dispatch_async(queue,^{/*read 100-199 bytes*/});
dispatch_async(queue,^{/*read 200-299 bytes*/});
```

相关API：
- `dispatch_io_create`：创建dispatch io;
- `dispatch_io_set_low_water`：指定切割文件大小;
- `dispatch_io_read`：读取切割的文件然后合并。

苹果系统日志API[源码](https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c)：

```objc
pipe_q = dispatch_queue_create("PipeQ", NULL);
//创建
pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(int err){
    close(fd);
});
*out_fd = fdpair[1];
//设置切割大小
dispatch_io_set_low_water(pipe_channel, SIZE_MAX);
dispatch_io_read(pipe_channel, 0, SIZE_MAX, pipe_q, ^(bool done, dispatch_data_t pipedata, int err){
    if (err == 0)
    {
        size_t len = dispatch_data_get_size(pipedata);
        if (len > 0)
        {
            //对每次切块数据的处理
            const char *bytes = NULL;
            char *encoded;
            uint32_t eval;
            dispatch_data_t md = dispatch_data_create_map(pipedata, (const void **)&bytes, &len);
            encoded = asl_core_encode_buffer(bytes, len);
            asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded);
            free(encoded);
            eval = _asl_evaluate_send(NULL, (aslmsg)aux, -1);
            _asl_send_message(NULL, eval, aux, NULL);
            asl_msg_release(aux);
            dispatch_release(md);
        }
    }
    if (done)
    {
        //semaphore +1使得不需要再等待继续执行下去。
        dispatch_semaphore_signal(sem);
        dispatch_release(pipe_channel);
        dispatch_release(pipe_q);
    }
});
```

## [Dispatch Source](https://developer.apple.com/documentation/dispatch/dispatch_source?language=occ)
Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。

| 方法 | 说明 |
| - | - |
| DISPATCH_SOURCE_TYPE_DATA_ADD | 数据增加 |
| DISPATCH_SOURCE_TYPE_DATA_OR | 数据OR |
| DISPATCH_SOURCE_TYPE_MACH_SEND | Mach端口发送 |
| DISPATCH_SOURCE_TYPE_MACH_RECV | Mach端口接收 |
| DISPATCH_SOURCE_TYPE_MEMORYPRESSURE | 内存情况 |
| DISPATCH_SOURCE_TYPE_PROC | 进程事件 |
| DISPATCH_SOURCE_TYPE_READ | 读数据 |
| DISPATCH_SOURCE_TYPE_SIGNAL | 信号 |
| DISPATCH_SOURCE_TYPE_TIMER | 定时器 |
| DISPATCH_SOURCE_TYPE_VNODE | 文件系统变化 |
| DISPATCH_SOURCE_TYPE_WRITE | 文件写入 |

相关API：
- `dispatch_source_create`：创建 dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。
- `dispatch_source_set_event_handler`：设置事件处理 handler
- `dispatch_source_set_cancel_handler`：事件取消 handler，就是在 dispatch source 释放前做些清理的事。
- `dispatch_source_cancel`：关闭 dispatch source，设置的事件处理 handler 不会被执行，已经执行的事件 handler 不会取消。

```objc
/**
 * 监视文件夹内文件变化
 */
- (void)dispatchSourceDirectoryDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchSourceDirectoryDemo---begin");
    
    NSURL *directoryURL; // assume this is set to a directory
    int const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);
    if (fd < 0) {
        char buffer[80];
        strerror_r(errno, buffer, sizeof(buffer));
        NSLog(@"Unable to open \"%@\": %s (%d)", [directoryURL path], buffer, errno);
        return;
    }
    dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,
                                                      DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);
    dispatch_source_set_event_handler(source, ^(){
        unsigned long const data = dispatch_source_get_data(source);
        if (data & DISPATCH_VNODE_WRITE) {
            NSLog(@"The directory changed.");
        }
        if (data & DISPATCH_VNODE_DELETE) {
            NSLog(@"The directory has been deleted.");
        }
    });
    dispatch_source_set_cancel_handler(source, ^(){
        close(fd);
    });
    dispatch_resume(source);
    // 注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听
    
    NSLog(@"dispatchSourceDirectoryDemo---end");
}
```

NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下:

```objc
@implementation ViewController {
    dispatch_source_t sourceTimer;
}

/**
 * 设置与 runloop 无关定时器
 */
// dispatch source timer demo
- (void)dispatchSourceTimerDemo {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchSourceTimerDemo---begin");
    
    sourceTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);
    dispatch_source_set_event_handler(sourceTimer, ^(){
        NSLog(@"Time flies.");
    });
    dispatch_source_set_timer(sourceTimer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 10 * NSEC_PER_MSEC);
    dispatch_resume(sourceTimer);
    
    NSLog(@"dispatchSourceTimerDemo---end");
}
```

执行结果：

```
2020-01-01 16:30:16.150561+0800 GCDDemo[32862:3297246] currentThread---<NSThread: 0x600001c5f7c0>{number = 1, name = main}
2020-01-01 16:30:16.150677+0800 GCDDemo[32862:3297246] dispatchSourceTimerDemo---begin
2020-01-01 16:30:16.150812+0800 GCDDemo[32862:3297246] dispatchSourceTimerDemo---end
2020-01-01 16:30:16.151072+0800 GCDDemo[32862:3297481] Time flies.
2020-01-01 16:30:18.160743+0800 GCDDemo[32862:3297481] Time flies.
2020-01-01 16:30:20.160736+0800 GCDDemo[32862:3297480] Time flies.
```

> 注意：sourceTimer 需要是全局变量或属性，否则第一次运行完后，ARC就会把它释放掉了，RunLoop 扫描不到这个 timer 了。

## [Dispatch Semaphore](https://developer.apple.com/documentation/dispatch/dispatch_semaphore?language=objc)
相关API：
- `dispatch_semaphore_create`：创建一个 Semaphore 并初始化信号的总量;
- `dispatch_semaphore_signal`：发送一个信号，让信号总量加 1;
- `dispatch_semaphore_wait`：可以使总信号量减 1，信号总量小于 0 时就会一直等待（阻塞所在线程），否则就可以正常执行。

实际应用：
- 保持线程同步，将异步执行任务转换为同步执行任务
- 保证线程安全，为线程加锁

```objc
/**
 * semaphore 线程同步
 */
- (void)dispatchSemaphoreThreadSyncDemo {
    
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchSemaphoreThreadSyncDemo---begin");
    
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    
    __block int number = 0;
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2.f];                // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);         // 打印当前线程
        number = 100;
        
        dispatch_semaphore_signal(semaphore);
    });
    
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    
    NSLog(@"dispatchSemaphoreThreadSyncDemo---end, number = %d", number);
}
```

执行结果：

```
2020-01-01 16:48:43.214260+0800 GCDDemo[34328:3358479] currentThread---<NSThread: 0x600003d5ad00>{number = 1, name = main}
2020-01-01 16:48:43.214383+0800 GCDDemo[34328:3358479] dispatchSemaphoreThreadSyncDemo---begin
2020-01-01 16:48:45.215141+0800 GCDDemo[34328:3358765] 1---<NSThread: 0x600003d38600>{number = 4, name = (null)}
2020-01-01 16:48:45.215281+0800 GCDDemo[34328:3358479] dispatchSemaphoreThreadSyncDemo---end, number = 100
```

```objc
/**
 * 使用 semaphore 保证线程安全
 * 初始化火车票数量、卖票窗口（非线程安全）、并开始卖票
 * safe：指定是否使用安全模式
 */
- (void)dispatchSemaphoreThreadSafeDemo:(BOOL)safe {
    NSLog(@"currentThread---%@", [NSThread currentThread]);  // 打印当前线程
    NSLog(@"dispatchSemaphoreThreadSafeDemo---begin");
    
    if (safe) {
        semaphoreLock = dispatch_semaphore_create(1);
    }
    
    self.ticketSurplusCount = 20;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        if (safe) {
            [weakSelf saleTicketSafe];
        } else {
            [weakSelf saleTicketNotSafe];
        }
    });
    
    dispatch_async(queue2, ^{
        if (safe) {
            [weakSelf saleTicketSafe];
        } else {
            [weakSelf saleTicketNotSafe];
        }
    });
    
    NSLog(@"dispatchSemaphoreThreadSafeDemo---end");
}


/**
 * 售卖火车票（非线程安全）
 */
- (void)saleTicketNotSafe {
    while (1) {
        //如果还有票，继续售卖
        if (self.ticketSurplusCount > 0) {
            self.ticketSurplusCount--;
            NSLog(@"%@", [NSString stringWithFormat:@"剩余票数：%d 窗口：%@", self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { // 如果已卖完，关闭售票窗口
            NSLog(@"所有火车票均已售完");
            break;
        }
    }
}


/**
 * 售卖火车票（线程安全）
 */
- (void)saleTicketSafe {
    while (1) {
        // 相当于加锁
        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);
        
        // 如果还有票，继续售卖
        if (self.ticketSurplusCount > 0) {
            self.ticketSurplusCount--;
            NSLog(@"%@", [NSString stringWithFormat:@"剩余票数：%d 窗口：%@", self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { // 如果已卖完，关闭售票窗口
            NSLog(@"所有火车票均已售完");
            
            // 相当于解锁
            dispatch_semaphore_signal(semaphoreLock);
            break;
        }
        
        // 相当于解锁
        dispatch_semaphore_signal(semaphoreLock);
    }
}
```

执行结果：

```
线程安全：
2020-01-01 17:08:02.730692+0800 GCDDemo[35948:3441575] currentThread---<NSThread: 0x600003b20040>{number = 1, name = main}
2020-01-01 17:08:02.730864+0800 GCDDemo[35948:3441575] dispatchSemaphoreThreadSafeDemo---begin
2020-01-01 17:08:02.731067+0800 GCDDemo[35948:3441849] 剩余票数：19 窗口：<NSThread: 0x600003b6a680>{number = 3, name = (null)}
2020-01-01 17:08:02.934852+0800 GCDDemo[35948:3441843] 剩余票数：18 窗口：<NSThread: 0x600003b67f80>{number = 6, name = (null)}
2020-01-01 17:08:03.137926+0800 GCDDemo[35948:3441849] 剩余票数：17 窗口：<NSThread: 0x600003b6a680>{number = 3, name = (null)}
...
2020-01-01 17:08:05.980200+0800 GCDDemo[35948:3441849] 剩余票数：3 窗口：<NSThread: 0x600003b6a680>{number = 3, name = (null)}
2020-01-01 17:08:06.184926+0800 GCDDemo[35948:3441843] 剩余票数：2 窗口：<NSThread: 0x600003b67f80>{number = 6, name = (null)}
2020-01-01 17:08:06.387919+0800 GCDDemo[35948:3441849] 剩余票数：1 窗口：<NSThread: 0x600003b6a680>{number = 3, name = (null)}
2020-01-01 17:08:06.588691+0800 GCDDemo[35948:3441843] 剩余票数：0 窗口：<NSThread: 0x600003b67f80>{number = 6, name = (null)}
2020-01-01 17:08:06.791144+0800 GCDDemo[35948:3441849] 所有火车票均已售完
2020-01-01 17:08:06.791260+0800 GCDDemo[35948:3441843] 所有火车票均已售完

非线程安全：
2020-01-01 17:11:33.154248+0800 GCDDemo[36299:3459425] currentThread---<NSThread: 0x60000181e1c0>{number = 1, name = main}
2020-01-01 17:11:33.154360+0800 GCDDemo[36299:3459425] dispatchSemaphoreThreadSafeDemo---begin
2020-01-01 17:11:33.154479+0800 GCDDemo[36299:3459425] dispatchSemaphoreThreadSafeDemo---end
2020-01-01 17:11:33.154527+0800 GCDDemo[36299:3459703] 剩余票数：19 窗口：<NSThread: 0x600001844f40>{number = 3, name = (null)}
2020-01-01 17:11:33.154536+0800 GCDDemo[36299:3459697] 剩余票数：18 窗口：<NSThread: 0x60000184a440>{number = 5, name = (null)}
2020-01-01 17:11:33.354900+0800 GCDDemo[36299:3459703] 剩余票数：17 窗口：<NSThread: 0x600001844f40>{number = 3, name = (null)}
2020-01-01 17:11:33.354900+0800 GCDDemo[36299:3459697] 剩余票数：17 窗口：<NSThread: 0x60000184a440>{number = 5, name = (null)}
...
2020-01-01 17:11:34.972789+0800 GCDDemo[36299:3459703] 剩余票数：4 窗口：<NSThread: 0x600001844f40>{number = 3, name = (null)}
2020-01-01 17:11:34.972789+0800 GCDDemo[36299:3459697] 剩余票数：4 窗口：<NSThread: 0x60000184a440>{number = 5, name = (null)}
2020-01-01 17:11:35.173406+0800 GCDDemo[36299:3459697] 剩余票数：2 窗口：<NSThread: 0x60000184a440>{number = 5, name = (null)}
2020-01-01 17:11:35.173406+0800 GCDDemo[36299:3459703] 剩余票数：3 窗口：<NSThread: 0x600001844f40>{number = 3, name = (null)}
2020-01-01 17:11:35.377816+0800 GCDDemo[36299:3459697] 剩余票数：0 窗口：<NSThread: 0x60000184a440>{number = 5, name = (null)}
2020-01-01 17:11:35.377812+0800 GCDDemo[36299:3459703] 剩余票数：1 窗口：<NSThread: 0x600001844f40>{number = 3, name = (null)}
2020-01-01 17:11:35.582372+0800 GCDDemo[36299:3459703] 所有火车票均已售完
2020-01-01 17:11:35.582372+0800 GCDDemo[36299:3459697] 所有火车票均已售完
```

## [NSLock](https://developer.apple.com/documentation/foundation/nslock)
iOS中常用锁及其性能：
- `NSRecursiveLock`：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。
- `NSDistributedLock`：分布锁，基于文件方式的锁机制，可以跨进程访问。
- `NSConditionLock`：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。
- `OSSpinLock`：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用 pthread_mutex 较好。
- `pthread_mutex_t`：同步锁基于C语言，底层API性能高，使用方法和其它的类似。
- `@synchronized`：更加简单。

## [dispatch_suspend](https://developer.apple.com/documentation/dispatch/1452801-dispatch_suspend?language=occ) 和 [dispatch_resume](https://developer.apple.com/documentation/dispatch/1452929-dispatch_resume?language=objc)
- `dispatch_suspend`：挂起任务，不会暂停正在执行的 block，只是能够暂停还没执行的 block。
- `dispatch_resume`：恢复任务。

## 其它操作
- `dispatch_set_context`：为队列添加上下文数据；
- `dispatch_get_context`：获取队列上下文数据；
- `dispatch_set_finalizer_f`：转移内存管理权限

## 常见死锁场景
当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。

```objc
- (void)deadLockCase1 {
    NSLog(@"1---%@", [NSThread currentThread]);
    // 主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2---%@", [NSThread currentThread]);
    });
    NSLog(@"3---%@", [NSThread currentThread]);
}

// Dead Lock case 2
- (void)deadLockCase2 {
    NSLog(@"1---%@", [NSThread currentThread]);
    // 3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行
    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        NSLog(@"2---%@", [NSThread currentThread]);
    });
    NSLog(@"3---%@", [NSThread currentThread]);
}

// Dead Lock case 3
- (void)deadLockCase3 {
    dispatch_queue_t serialQueue = dispatch_queue_create("com.rodgerjluo.gcddemo.serialqueue", DISPATCH_QUEUE_SERIAL);
    NSLog(@"1---%@", [NSThread currentThread]);
    dispatch_async(serialQueue, ^{
        NSLog(@"2---%@", [NSThread currentThread]);
        // 串行队列里面同步一个串行队列就会死锁
        dispatch_sync(serialQueue, ^{
            NSLog(@"3---%@", [NSThread currentThread]);
        });
        NSLog(@"4---%@", [NSThread currentThread]);
    });
    NSLog(@"5---%@", [NSThread currentThread]);
}

// Dead Lock case 4
- (void)deadLockCase4 {
    NSLog(@"1---%@", [NSThread currentThread]);
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@"2---%@", [NSThread currentThread]);
        // 将同步的串行队列放到另外一个线程就能够解决
        dispatch_sync(dispatch_get_main_queue(), ^{
            NSLog(@"3---%@", [NSThread currentThread]);
        });
        NSLog(@"4---%@", [NSThread currentThread]);
    });
    NSLog(@"5---%@", [NSThread currentThread]);
}


// Dead Lock case 5
- (void)deadLockCase5 {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@"1---%@", [NSThread currentThread]);
        // 回到主线程发现死循环后就没法执行了
        dispatch_sync(dispatch_get_main_queue(), ^{
            NSLog(@"2---%@", [NSThread currentThread]);
        });
        NSLog(@"3---%@", [NSThread currentThread]);
    });
    NSLog(@"4---%@", [NSThread currentThread]);
    // 死循环
    while (1) {

    }
}
```

- 本文对应[Demo](https://github.com/rodger1017/Study/tree/master/GCDDemo)

# 参考资料
- [Grand Central Dispatch](https://apple.github.io/swift-corelibs-libdispatch/)
- [细说 GCD（Grand Central Dispatch）如何用](https://ming1016.github.io/2016/01/13/how-to-use-gcd/)
- [iOS 多线程：『GCD』详尽总结](https://www.jianshu.com/p/2d57c72016c6)